#!/usr/bin/env python
# -*-Python-*-

# Author: P. N. Hilfinger

# For usage, see Usage procedure (or invoke the command without arguments).
# Feel free to adapt this script to your needs.

import sys, os, re
import threading
from subprocess import Popen, PIPE
import signal
from Queue import Queue, Empty, Full
import time
from getopt import getopt
import traceback
   		      
DEFAULT_TIMEOUT = 5.0 * 60.0
QUANTUM = 0.125

def Dbg(msg, *args):
    print >>sys.stderr, msg % args
    sys.stderr.flush()

def Log(msg, *args):
    if log:
        print >>log, msg % args

def Usage():
    print >>sys.stderr, """\
Usage: test-jump61 OPTIONS FILE.inp ...

   For each FILE.inp, performs the indicated scripts, and compares any board
   output (between "===" markers) with the file FILE.std, if present.

   Each FILE.inp should contain specifications for one run of jump61, as follows:
     * The file has the form
            # Any number of comment lines, starting with #.
            COMMAND1
            COMMAND2
            ===#1===
            INPUT1
            ===#2===
            INPUT2
      * COMMAND1 and COMMAND2 are the Unix command lines to start the
        two programs.  COMMAND2 can be "None", indicating that
        there is only one program.
      * INPUT1 and INPUT2 are the commands to be fed to the programs.  INPUT2
        is ignored if there is only one program.
        The commands may be the usual inputs to jump61, as well as the following
        special commands:
            %ib    Wait for a blue move from the other program and insert
                   it here.
            %ir    Wait for a red move from the other program and insert
                   it here.
            %mb    Wait for this program to print a blue move, and send it to
                   the other program.  A "blue move" is a line such as
                   "Blue moves 3 2.", as specified in the spec.
            %mr    Wait for this program to print a red move, and send it to
                   the other program.
            %br    Wait for a sequence of alternating blue and red moves from
                   this program, starting with blue, up to an announcement of
                   a winner.
            %rb    As for %br, but starting with a red move.
            %ib... As for %ib, and then wait for a red move from this
                   program, send it to the other program, and then repeat
                   these steps up to an announcement of a winner.
            %ir... As for %ir, and then wait for a blue move from this
                   program, send it to the other program, and then repeat
                   these steps up to an announcement of a winner.
            %e     Indicates a point where test-jump61 expects an announcement
                   of a winner (for either side).
            %eb    As for %e, but expects to see "Blue wins."
            %er    As for %e, but expects to see "Red wins."
            %ae    As for %e, but also prints winner.

 OPTIONS:

   --time=MINUTES Default time limit for each side's total moves in minutes.

   --show=N    Display up to N input files that cause failures.

   --std       For each input file, F.inp, create file F.std.tmp containing
               the output generated by the programs tested.

   --verbose   Same as --verbosity=1

   --verbosity=N  Sets verbosity level to N."""
    sys.exit(1)

        
def Match(patn, text):
    global _match
    _match = re.match(patn, text)
    return _match

def Search(patn, text):
    global _match
    _match = re.search(patn, text)
    return _match

def Group(i):
    return _match.group(i)

def Open(name):
    try:
        return open(name)
    except:
        return None

def Close(f):
    try:
        f.close()
    except:
        pass


def output_queuer(id, out_stream):
    """Return a Queue that gathers the lines of output from OUT_STREAM,
    followed by an empty string (since all other lines end in "\\n", this
    unambiguously signals end of input).  Uses ID in messages at odd
    verbosity levels to indicate where output came from."""
    def transfer():
        while True:
            try:
                line = out_stream.readline()
                if verbose & 1:
                    Msg("<%s: %s\n", id, line.rstrip())
                queue.put(line)
            except:
                return
            if line == "":
                return
    queue = Queue(2048)
    task = threading.Thread(target=transfer)
    task.setDaemon(True)
    task.start()
    return queue

def queue_writer(output, Q = None):
    """Set up a thread to write the contents of Q to OUTPUT.  The thread is a
    daemon, and therefore need not be shut down.  If defaulted, a new queue
    of unlimited size is used.  Returns the queue."""
    def transfer():
        while True:
            line = Q.get(True)
            output.write(line)
    Q = Q or Queue(0)
    task = threading.Thread(target=transfer)
    task.setDaemon(True)
    task.start()
    return Q

class Move_Error(Exception):
    pass

class Spec_Error(Exception):
    pass

class Win(Exception):
    pass

msgs = queue_writer(sys.stderr)

def Msg(format, *args):
    msgs.put(format % args if args else format)

class Action(object):
    def __init__(self, source, winner=None, player=None, row=None, col=None,
                 board=None, error=None):
        self._error = error
        if error:
            board = source = winner = player = row = col = None
            
        self._board = board
        self._source = source
        self._winner = winner
        self._player = player
        self._row = row
        self._col = col

    @staticmethod
    def parse_line(m):
        if Search(r'(Red|Blue) wins\.', m):
            r = Action(Group(0), winner=Group(1))
        elif Search(r'(Red|Blue) moves (\d+) (\d+)\.', m):
            r = Action(Group(0), player=Group(1),
                       row=int(Group(2)), col=int(Group(3)))
        elif Search('===', m):
            r = Action(Group(0), board='===\n')
        else:
            r = None
        m0 = m
        if r:
            m = m[0:_match.start()] + m[_match.end():]
        if Search(r'===|\bwins\b|\bmoves\b', m):
            return Action(m0, error = True)
        else:
            return r
            
    def is_error(self):
        return self._error

    def winner(self):
        return self._winner

    def is_move(self):
        return self._player

    def player(self):
        return self._player

    def row(self):
        return self._row

    def col(self):
        return self._col

    def is_board(self):
        return self._board

    def add_to_board(self, line):
        self._board += line.rstrip() + "\n"
        
    def move_command(self):
        return "%d %d" % (self._row, self._col)

    def __str__(self):
        if self._error:
            return 'Error[' + self._source + ']'
        elif self._winner:
            return "%s wins." % (self._winner,)
        elif self._board:
            return self._board.rstrip()
        else:
            return "%s moves %d %d." % (self._player, self._row, self._col)
    
    def __repr__(self):
        return str(self)
            

class Prog(object):
    def __init__(self, id, command, inputs, time_limit):
        command = Popen('echo ' + command, shell=True,
                        stdin=PIPE, stdout=PIPE, stderr=PIPE).communicate()[0]
        self.proc = Popen(re.split(r'\s+', command.strip()),
                          stdin=PIPE, stdout=PIPE, stderr=PIPE)
        Log("Start pid %s; %s", self.proc.pid, command)
        self.id = id
        self.inputs = list(inputs)
        self.outputs = []
        self.out_queue = output_queuer(id, self.proc.stdout)
        self.err_queue = output_queuer(id + "(e)", self.proc.stderr)
        self.output_moves = []
        self.input_moves = Queue(2)
        self.time_limit = time_limit
        self._board = None
        self.finishing = False

    def send_move(self, move):
        """Send SELF the Action MOVE, which either a win or a move."""
        try:
            self.input_moves.put(move, False)
        except Full:
            self._move_error("other command is not responding")

    def run(self, other):
        """Run my command, using OTHER as the opposing program (None if none)."""
        self.other = other
        self.time_left = { 'Blue': self.time_limit, 'Red': self.time_limit }
        try:
            for inp in self.inputs:
                if Match(r'\s*%(\S*)', inp):
                    self._subcommands.get(Group(1), self._bad_command)(self)
                else:
                    self._await_my_move(QUANTUM)
                    self._input(inp)
            self._await_my_move(1.0)
        except Move_Error, excp:
            self._report_termination(excp)
        except BaseException, excp:
            self._report_termination(Move_Error("%s: terminated on exception (%s)"
                                                % (self.id, repr(excp))))
        finally:
            self.finish()

    def _input(self, line):
        """Send LINE to my process's input."""
        if line[-1] != '\n':
            line += '\n'
        if verbose & 1:
            Msg(">%s: %s", self.id, line)
        try:
            self.proc.stdin.write(line)
            self.proc.stdin.flush()
        except:
            if verbose & 1:
                Msg("%s: process terminated (refused input of '%s')",
                    self.id, line.rstrip())
            raise

    def _add_move(self, m, front = False):
        """Add Action M to my pending outputs.  Add to the front iff FRONT,
        and else to the end."""
        if front:
            self.output_moves.insert(0, m)
        else:
            self.output_moves.append(m)

    def _move_error(self, msg, *args):
        """Signal an error with the given MSG format string and ARGS."""
        
        if verbose & 2:
            Dbg("%s: error %s", self.id, msg%args)
        raise Move_Error(self.id + ": " + msg % args)

    def _report_termination(self, excp):
        """Indicate that I have terminated and how."""
        for i in xrange(3):
            if self.proc.poll() is not None:
                break
            time.sleep(2*QUANTUM)

        if excp:
            raise excp
        elif self.proc.returncode is None:
            self._move_error("%s: hung", self.id)
        else:
            self._move_error("%s: terminated unexpectedly", self.id)

    def _report_timeout(self, who):
        if who is None:
            self._move_error("game appears to be hung")
        else:
            self._move_error("%s player ran out of time", who.lower())
        
    def _start_time(self, who):
        self._time0 = time.time()

    def _stop_time(self, who):
        self.time_left[who] -= time.time() - self._time0
        if self.time_left[who] < 0:
            self._report_timeout(who)

    def _process_out(self, line):
        """Process one line of output from my process, placing any resulting
        board output in my outputs queue and any resulting wins or moves in
        my output to the other process."""
        if self._board:
            self._board.add_to_board(line)
            if Match(r'===\s*$', line):
                self.outputs.append(str(self._board))
                self._board = None
            return

        m = Action.parse_line(line)
        if not m:
            pass
        elif m.is_board():
            self._board = m
        elif m.is_error():
            self._move_error(m.error_msg())
        else:
            self._add_move(m)

    def _await_my_move(self, timeout):
        """Wait, processing output, until SELF.output_moves is non-empty
        or TIMEOUT elapses."""
        if not self.output_moves and timeout > 0:
            while True:
                try:
                    err_line = self.err_queue.get_nowait()
                except Empty:
                    break
        while not self.output_moves and timeout > 0:
            time0 = time.time()
            try:
                self._process_out(self.out_queue.get(True, QUANTUM))
            except Empty:
                pass
            timeout -= time.time() - time0
            if self._finishing():
                break

    def _get_remote_move(self, who, allow_end):
        """Get the next move or win sent to me."""
        while True:
            self._start_time(who)
            try:
                m = self.input_moves.get(True, QUANTUM)
                break
            except Empty:
                pass
            finally:
                self._stop_time(who)
            if self._finishing():
                self._move_error("process shut down")

        if m.winner():
            if allow_end:
                return m
            else:
                self._move_error("unexpected end of game received")
        if not m.is_move():
            self._move_error("received incorrectly formatted move")
        if m.player() != who:
            self._move_error("received remote move for wrong player: %s", m)
        return m

    def _get_local_move(self, who):
        """Get the next move or win output by my process."""
        if who:
            self._start_time(who)
            self._await_my_move(self.time_left[who])
            self._stop_time(who)
        else:
            self._await_my_move(6.0)
        if not self.output_moves:
            self._report_timeout(who)
        m = self.output_moves.pop(0)
            
        if m.winner():
            pass
        elif m.is_error():
            self._move_error("received incorrectly formatted move")
        elif m.player() != who:
            self._move_error("received local move for wrong player: %s", m)
        return m

    def _bad_command(self):
        raise Spec_Error('bad command')

    def ib1(self):
        self._await_my_move(2*QUANTUM)
        self._input(self._get_remote_move('Blue', False).move_command())

    def ir1(self):
        self._await_my_move(2*QUANTUM)
        m = self._get_remote_move('Red', False)
        self._input(m.move_command())

    def mb(self):
        m = self._get_local_move('Blue')
        if m.winner():
            self._move_error("game ends unexpectedly")
        if self.other:
            self.other.send_move(m)
            
    def mr(self):
        m = self._get_local_move('Red')
        if m.winner():
            self._move_error("game ends unexpectedly")
        if self.other:
            self.other.send_move(m)

    def br(self):
        while True:
            m = self._get_local_move('Blue')
            if m.winner():
                self._add_move(m, front=True)
                return
            m = self._get_local_move('Red')
            if m.winner():
                self._add_move(m, front=True)
                return

    def rb(self):
        while True:
            m = self._get_local_move('Red')
            if m.winner():
                self._add_move(m, front=True)
                return
            m = self._get_local_move('Blue')
            if m.winner():
                self._add_move(m, front=True)
                return

    def ibn(self):
        self.ib1()
        while True:
            m = self._get_local_move('Red')
            self.other.send_move(m)
            if m.winner():
                self._add_move(m, front=True)
                return
            m = self._get_remote_move('Blue', True)
            if m.winner():
                return
            else:
                self._input(m.move_command())
        
    def irn(self):
        self.ir1()
        while True:
            m = self._get_local_move('Blue')
            self.other.send_move(m)
            if m.winner():
                self._add_move(m, front=True)
                return
            m = self._get_remote_move('Red', True)
            if m.winner():
                return
            else:
                self._input(m.move_command())

    def e(self):
        m = self._get_local_move(None)
        if not m.winner():
            self._move_error("end of game expected, but not received")

    def eb(self):
        m = self._get_local_move(None)
        w = m.winner()
        if not w:
            self._move_error("end of game expected, but not received")
        elif w != 'Blue':
            self._move_error("expected win for Blue")


    def er(self):
        m = self._get_local_move(None)
        w = m.winner()
        if not w:
            self._move_error("end of game expected, but not received")
        elif w != 'Red':
            self._move_error("expected win for Red")

    def ae(self):
        m = self._get_local_move(None)
        w = m.winner()
        if not w:
            self._move_error("end of game expected, but not received")
        else:
            raise Win(w + " wins")

    _subcommands = { 'ib': ib1, 'ir': ir1, 'mb': mb, 'mr': mr,
                     'br': br, 'rb': rb, 
                     'ib...': ibn, 'ir...': irn,
                     'e': e, 'eb': eb, 'er': er, 'ae': ae }

    def procDone(self):
        if self.proc is None:
            return False
        return self.proc.poll()

    def _finishing(self):
        return self.finishing or self.proc.poll() is not None

    def finish(self):
        proc = self.proc
        if proc is None:
            return
        Close(proc.stdin)
        try:
            self._await_my_move(2*QUANTUM)
        except:
            pass
        time.sleep(2*QUANTUM)
        Close(proc.stdout)
        Close(proc.stderr)
        self.finishing = True
        if proc.poll() is None:
            try:
                Log("kill pid %s", proc.pid)
                os.kill(proc.pid, signal.SIGKILL)
            except:
                Log("failed to kill pid %s", proc.pid)
            try:
                Log("wait for pid %s", proc.pid)
                proc.wait()
            except:
                Log("wait for pid %s failed", proc.pid)
        else:
            Log("proc poll on pid %s succeeded", proc.pid)
        return proc.returncode

def parse_spec(name):
    """Read FILE and return the specified test as a tuple:
       (OPTIONS1, OPTIONS2, INPUTS1, INPUTS2, MAXTIME)."""
    inp = Open(name)
    if inp is None:
        raise Spec_Error("test file does not exist")
    def read_next():
        while True:
            line = inp.readline()
            if line == '':
                return ''
            if not Match(r'\s*#|\s*$', line):
                return line.strip()
            
    try:
        command1 = read_next()
        command2 = read_next()
        if command2 == '':
            raise Spec_Error("truncated specification")
        sep = read_next()
        if sep != '===#1===':
            raise Spec_Error("bad input separator")
        inputs1 = []
        while True:
            line = inp.readline()
            if line == '' and command2 != "None":
                raise Spec_Error("truncated input")
            elif line == '' or line == '===#2===\n':
                break
            inputs1.append(line)
        inputs2 = []
        while True:
            line = inp.readline()
            if line == '':
                break
            inputs2.append(line)

        if Match(r'.*--time=([-\d.]+)', command1):
            time1 = float(Group(1)) * 60.0
        else:
            time1 = move_timeout
        if command2 == 'None':
            time2 = 0.0
        elif Match(r'.*--time=([-\d.]+)', command2):
            time2 = float(Group(1)) * 60.0
        else:
            time2 = move_timeout

        return command1, command2, inputs1, inputs2, max(time1, time2)
    finally:
        Close(inp)

def run_test(test, std):
    terminating = [ False, False ]
    command1, command2, inputs1, inputs2, time_limit = parse_spec(test)
    progs = [ None, None ]
    progs[0] = Prog("Program 1", command1, inputs1, time_limit)
    if command2 == 'None':
        progs[1] = None
    else:
        progs[1] = Prog("Program 2", command2, inputs2, time_limit)

    def prog_thread(k):
        p = progs[k]
        if p is None:
            return
        try:
            p.run(progs[1-k])
            terminating[k] = True
        except Move_Error, e:
            terminating[k] = e
        except Win, e:
            terminating[k] = e
        except BaseException, e:
            if len(e.args) == 1:
                terminating[k] = Move_Error(e.message)
            else:
                terminating[k] = Move_Error(repr(e))
            traceback.print_tb(sys.exc_info()[2])
        
    def convert(lines):
        return '\n'.join(map(lambda s: s.rstrip(), lines)) + '\n'

    t1 = threading.Thread(target=prog_thread, args=(0,))
    t2 = threading.Thread(target=prog_thread, args=(1,))
    t1.start()
    t2.start()
    time0 = time.time()
    limit = 2.25 * time_limit + 5.0
    while True:
        t1.join(2*QUANTUM)
        t2.join(2*QUANTUM)
        elapsed = time.time() - time0
        code = None
        if elapsed > limit or terminating[0] or terminating[1] \
           or progs[0].procDone() or (progs[1] and progs[1].procDone()):
            if elapsed > limit:
                Msg("overall time limit exceeded.")
            progs[0].finish()            
            if progs[1]:
                progs[1].finish()
            break

    if progs[0].procDone() not in [0, -9]:
        raise Move_Error("Program #1 terminated with code %s" %
                         progs[0].procDone())
    if progs[1] and progs[1].procDone() not in [0, -9]:
        raise Move_Error("Program #2 terminated with code %s" %
                         progs[1].procDone())

    if type(terminating[0]) is not bool:
        raise terminating[0]
    if type(terminating[1]) is not bool:
        raise terminating[1]
    outputs = ["Program #1:\n"] + progs[0].outputs
    if progs[1] is not None:
        outputs += ["Program #2:\n"]
        outputs += progs[1].outputs
    if make_std:
        new_std = open(std + ".tmp", "w")
        for line in outputs:
            print >>new_std, line.rstrip()
        new_std.close()
    output = convert(outputs)
    stdfile = Open(std)
    if stdfile is not None:
        std_output = convert(stdfile.readlines())
        stdfile.close()
        if output != std_output:
            if verbose & 1:
                Msg("output = \n%s\n", output)
                Msg("std output = \n%s\n", std_output)
            raise Move_Error("wrong output")

def run_tests(files, show):
    N = 0
    fail = spec_errs = 0
    for test in args:
        if not os.path.exists(test):
            continue
        N += 1
        name = os.path.splitext(os.path.basename(test))[0]
        std = os.path.join(os.path.dirname(test), name + ".std")
        try:
            run_test(test, std)
            msg = "OK"
        except Spec_Error, e:
            msg = "ERROR (%s)" % e.args[0]
            spec_errs += 1
        except Move_Error, e:
            msg = "FAIL (%s)" % e.args[0]
            fail += 1
            if show and show > 0:
                inp = open(test)
                msg += "\ntest-jump61 input file:" \
                       + "\n===================================\n" \
                       + inp.read().rstrip() \
                       + "\n===================================" 
                show -= 1
                inp.close()
            elif show == 0:
                msg += " [input file not shown]"
        except Win, e:
            msg = e.args[0]
        print "%s: %s" % (name, msg)
        sys.stdout.flush()

    if fail == 0:
        print "Passed all %d tests." % (N - spec_errs,)
    else:
        print "Failed %d out of %d tests" \
              % (fail, N - spec_errs)
    if spec_errs:
        print "%d tests had missing or erroneous specification files." \
              % (spec_errs,)

    sys.exit(fail)

try:
    opts, args = getopt(sys.argv[1:], '',
                        ['verbose', 'verbosity=', 'show=', 'time=', 'std',
                         'log='])
except:
    Usage()

move_timeout = DEFAULT_TIMEOUT
verbose = 0
show = None
make_std = False
log = None
for opt, val in opts:
    if opt == '--verbose':
        verbose = verbose or 1
    elif opt == '--verbosity':
        verbose=int(val)
    elif opt == '--time':
        try:
            move_timeout = float(val) * 60.0
        except:
            Usage()
    elif opt == '--show':
        show = int(val)
    elif opt == '--std':
        make_std = True
    elif opt == '--log':
        try:
            log = open(val, "w")
        except IOError, e:
            print >>sys.stderr, "Could not open log file:", e[1]
            sys.exit(1)

if not args:
    Usage()


try:
    run_tests(args, show)
finally:
    if log:
        log.close()

